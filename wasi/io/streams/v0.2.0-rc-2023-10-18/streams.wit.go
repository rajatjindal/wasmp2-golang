// Code generated by wit-bindgen-go. DO NOT EDIT.

//go:build !wasip1

// Package streams represents the interface "wasi:io/streams@0.2.0-rc-2023-10-18".
//
// WASI I/O is an I/O abstraction API which is currently focused on providing
// stream types.
//
// In the future, the component model is expected to add built-in stream types;
// when it does, they are expected to subsume this API.
package streams

import (
	poll "github.com/rajatjindal/wasip2-golang/wasi/io/poll/v0.2.0-rc-2023-10-18"
	"github.com/ydnar/wasm-tools-go/cm"
)

// Error represents the resource "wasi:io/streams@0.2.0-rc-2023-10-18#error".
//
// Contextual error information about the last failure that happened on
// a read, write, or flush from an `input-stream` or `output-stream`.
//
// This type is returned through the `stream-error` type whenever an
// operation on a stream directly fails or an error is discovered
// after-the-fact, for example when a write's failure shows up through a
// later `flush` or `check-write`.
//
// Interfaces such as `wasi:filesystem/types` provide functionality to
// further "downcast" this error into interface-specific error information.
//
//	resource error
type Error cm.Resource

// ResourceDrop represents the Canonical ABI function "resource-drop".
//
// Drops a resource handle.
//
//go:nosplit
func (self Error) ResourceDrop() {
	self.wasmimport_ResourceDrop()
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [resource-drop]error
//go:noescape
func (self Error) wasmimport_ResourceDrop()

// ToDebugString represents method "to-debug-string".
//
// Returns a string that's suitable to assist humans in debugging this
// error.
//
// The returned string will change across platforms and hosts which
// means that parsing it, for example, would be a
// platform-compatibility hazard.
//
//	to-debug-string: func() -> string
//
//go:nosplit
func (self Error) ToDebugString() string {
	var result string
	self.wasmimport_ToDebugString(&result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]error.to-debug-string
//go:noescape
func (self Error) wasmimport_ToDebugString(result *string)

// InputStream represents the resource "wasi:io/streams@0.2.0-rc-2023-10-18#input-stream".
//
// An input bytestream.
//
// `input-stream`s are *non-blocking* to the extent practical on underlying
// platforms. I/O operations always return promptly; if fewer bytes are
// promptly available than requested, they return the number of bytes promptly
// available, which could even be zero. To wait for data to be available,
// use the `subscribe` function to obtain a `pollable` which can be polled
// for using `wasi:io/poll`.
//
//	resource input-stream
type InputStream cm.Resource

// ResourceDrop represents the Canonical ABI function "resource-drop".
//
// Drops a resource handle.
//
//go:nosplit
func (self InputStream) ResourceDrop() {
	self.wasmimport_ResourceDrop()
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [resource-drop]input-stream
//go:noescape
func (self InputStream) wasmimport_ResourceDrop()

// BlockingRead represents method "blocking-read".
//
// Read bytes from a stream, after blocking until at least one byte can
// be read. Except for blocking, identical to `read`.
//
//	blocking-read: func(len: u64) -> result<list<u8>, stream-error>
//
//go:nosplit
func (self InputStream) BlockingRead(len_ uint64) cm.OKResult[cm.List[uint8], StreamError] {
	var result cm.OKResult[cm.List[uint8], StreamError]
	self.wasmimport_BlockingRead(len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]input-stream.blocking-read
//go:noescape
func (self InputStream) wasmimport_BlockingRead(len_ uint64, result *cm.OKResult[cm.List[uint8], StreamError])

// BlockingSkip represents method "blocking-skip".
//
// Skip bytes from a stream, after blocking until at least one byte
// can be skipped. Except for blocking behavior, identical to `skip`.
//
//	blocking-skip: func(len: u64) -> result<u64, stream-error>
//
//go:nosplit
func (self InputStream) BlockingSkip(len_ uint64) cm.OKResult[uint64, StreamError] {
	var result cm.OKResult[uint64, StreamError]
	self.wasmimport_BlockingSkip(len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]input-stream.blocking-skip
//go:noescape
func (self InputStream) wasmimport_BlockingSkip(len_ uint64, result *cm.OKResult[uint64, StreamError])

// Read represents method "read".
//
// Perform a non-blocking read from the stream.
//
// This function returns a list of bytes containing the data that was
// read, along with a `stream-status` which, indicates whether further
// reads are expected to produce data. The returned list will contain up to
// `len` bytes; it may return fewer than requested, but not more. An
// empty list and `stream-status:open` indicates no more data is
// available at this time, and that the pollable given by `subscribe`
// will be ready when more data is available.
//
// Once a stream has reached the end, subsequent calls to `read` or
// `skip` will always report `stream-status:ended` rather than producing more
// data.
//
// When the caller gives a `len` of 0, it represents a request to read 0
// bytes. This read should  always succeed and return an empty list and
// the current `stream-status`.
//
// The `len` parameter is a `u64`, which could represent a list of u8 which
// is not possible to allocate in wasm32, or not desirable to allocate as
// as a return value by the callee. The callee may return a list of bytes
// less than `len` in size while more bytes are available for reading.
//
//	read: func(len: u64) -> result<list<u8>, stream-error>
//
//go:nosplit
func (self InputStream) Read(len_ uint64) cm.OKResult[cm.List[uint8], StreamError] {
	var result cm.OKResult[cm.List[uint8], StreamError]
	self.wasmimport_Read(len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]input-stream.read
//go:noescape
func (self InputStream) wasmimport_Read(len_ uint64, result *cm.OKResult[cm.List[uint8], StreamError])

// Skip represents method "skip".
//
// Skip bytes from a stream.
//
// This is similar to the `read` function, but avoids copying the
// bytes into the instance.
//
// Once a stream has reached the end, subsequent calls to read or
// `skip` will always report end-of-stream rather than producing more
// data.
//
// This function returns the number of bytes skipped, along with a
// `stream-status` indicating whether the end of the stream was
// reached. The returned value will be at most `len`; it may be less.
//
//	skip: func(len: u64) -> result<u64, stream-error>
//
//go:nosplit
func (self InputStream) Skip(len_ uint64) cm.OKResult[uint64, StreamError] {
	var result cm.OKResult[uint64, StreamError]
	self.wasmimport_Skip(len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]input-stream.skip
//go:noescape
func (self InputStream) wasmimport_Skip(len_ uint64, result *cm.OKResult[uint64, StreamError])

// Subscribe represents method "subscribe".
//
// Create a `pollable` which will resolve once either the specified stream
// has bytes available to read or the other end of the stream has been
// closed.
// The created `pollable` is a child resource of the `input-stream`.
// Implementations may trap if the `input-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
//
//	subscribe: func() -> own<pollable>
//
//go:nosplit
func (self InputStream) Subscribe() Pollable {
	return self.wasmimport_Subscribe()
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]input-stream.subscribe
//go:noescape
func (self InputStream) wasmimport_Subscribe() Pollable

// OutputStream represents the resource "wasi:io/streams@0.2.0-rc-2023-10-18#output-stream".
//
// An output bytestream.
//
// `output-stream`s are *non-blocking* to the extent practical on
// underlying platforms. Except where specified otherwise, I/O operations also
// always return promptly, after the number of bytes that can be written
// promptly, which could even be zero. To wait for the stream to be ready to
// accept data, the `subscribe` function to obtain a `pollable` which can be
// polled for using `wasi:io/poll`.
//
//	resource output-stream
type OutputStream cm.Resource

// ResourceDrop represents the Canonical ABI function "resource-drop".
//
// Drops a resource handle.
//
//go:nosplit
func (self OutputStream) ResourceDrop() {
	self.wasmimport_ResourceDrop()
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [resource-drop]output-stream
//go:noescape
func (self OutputStream) wasmimport_ResourceDrop()

// BlockingFlush represents method "blocking-flush".
//
// Request to flush buffered output, and block until flush completes
// and stream is ready for writing again.
//
//	blocking-flush: func() -> result<_, stream-error>
//
//go:nosplit
func (self OutputStream) BlockingFlush() cm.ErrResult[struct{}, StreamError] {
	var result cm.ErrResult[struct{}, StreamError]
	self.wasmimport_BlockingFlush(&result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.blocking-flush
//go:noescape
func (self OutputStream) wasmimport_BlockingFlush(result *cm.ErrResult[struct{}, StreamError])

// BlockingSplice represents method "blocking-splice".
//
// Read from one stream and write to another, with blocking.
//
// This is similar to `splice`, except that it blocks until at least
// one byte can be read.
//
//	blocking-splice: func(src: own<input-stream>, len: u64) -> result<u64, stream-error>
//
//go:nosplit
func (self OutputStream) BlockingSplice(src InputStream, len_ uint64) cm.OKResult[uint64, StreamError] {
	var result cm.OKResult[uint64, StreamError]
	self.wasmimport_BlockingSplice(src, len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.blocking-splice
//go:noescape
func (self OutputStream) wasmimport_BlockingSplice(src InputStream, len_ uint64, result *cm.OKResult[uint64, StreamError])

// BlockingWriteAndFlush represents method "blocking-write-and-flush".
//
// Perform a write of up to 4096 bytes, and then flush the stream. Block
// until all of these operations are complete, or an error occurs.
//
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write`, and `flush`, and is implemented with the
// following pseudo-code:
//
//	let pollable = this.subscribe();
//	while !contents.is_empty() {
//	// Wait for the stream to become writable
//	poll-one(pollable);
//	let Ok(n) = this.check-write(); // eliding error handling
//	let len = min(n, contents.len());
//	let (chunk, rest) = contents.split_at(len);
//	this.write(chunk  );            // eliding error handling
//	contents = rest;
//	}
//	this.flush();
//	// Wait for completion of `flush`
//	poll-one(pollable);
//	// Check for any errors that arose during `flush`
//	let _ = this.check-write();         // eliding error handling
//
//	blocking-write-and-flush: func(contents: list<u8>) -> result<_, stream-error>
//
//go:nosplit
func (self OutputStream) BlockingWriteAndFlush(contents cm.List[uint8]) cm.ErrResult[struct{}, StreamError] {
	var result cm.ErrResult[struct{}, StreamError]
	self.wasmimport_BlockingWriteAndFlush(contents, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.blocking-write-and-flush
//go:noescape
func (self OutputStream) wasmimport_BlockingWriteAndFlush(contents cm.List[uint8], result *cm.ErrResult[struct{}, StreamError])

// BlockingWriteZeroesAndFlush represents method "blocking-write-zeroes-and-flush".
//
// Perform a write of up to 4096 zeroes, and then flush the stream.
// Block until all of these operations are complete, or an error
// occurs.
//
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
// the following pseudo-code:
//
//	let pollable = this.subscribe();
//	while num_zeroes != 0 {
//	// Wait for the stream to become writable
//	poll-one(pollable);
//	let Ok(n) = this.check-write(); // eliding error handling
//	let len = min(n, num_zeroes);
//	this.write-zeroes(len);         // eliding error handling
//	num_zeroes -= len;
//	}
//	this.flush();
//	// Wait for completion of `flush`
//	poll-one(pollable);
//	// Check for any errors that arose during `flush`
//	let _ = this.check-write();         // eliding error handling
//
//	blocking-write-zeroes-and-flush: func(len: u64) -> result<_, stream-error>
//
//go:nosplit
func (self OutputStream) BlockingWriteZeroesAndFlush(len_ uint64) cm.ErrResult[struct{}, StreamError] {
	var result cm.ErrResult[struct{}, StreamError]
	self.wasmimport_BlockingWriteZeroesAndFlush(len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.blocking-write-zeroes-and-flush
//go:noescape
func (self OutputStream) wasmimport_BlockingWriteZeroesAndFlush(len_ uint64, result *cm.ErrResult[struct{}, StreamError])

// CheckWrite represents method "check-write".
//
// Check readiness for writing. This function never blocks.
//
// Returns the number of bytes permitted for the next call to `write`,
// or an error. Calling `write` with more bytes than this function has
// permitted will trap.
//
// When this function returns 0 bytes, the `subscribe` pollable will
// become ready when this function will report at least 1 byte, or an
// error.
//
//	check-write: func() -> result<u64, stream-error>
//
//go:nosplit
func (self OutputStream) CheckWrite() cm.OKResult[uint64, StreamError] {
	var result cm.OKResult[uint64, StreamError]
	self.wasmimport_CheckWrite(&result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.check-write
//go:noescape
func (self OutputStream) wasmimport_CheckWrite(result *cm.OKResult[uint64, StreamError])

// Flush represents method "flush".
//
// Request to flush buffered output. This function never blocks.
//
// This tells the output-stream that the caller intends any buffered
// output to be flushed. the output which is expected to be flushed
// is all that has been passed to `write` prior to this call.
//
// Upon calling this function, the `output-stream` will not accept any
// writes (`check-write` will return `ok(0)`) until the flush has
// completed. The `subscribe` pollable will become ready when the
// flush has completed and the stream can accept more writes.
//
//	flush: func() -> result<_, stream-error>
//
//go:nosplit
func (self OutputStream) Flush() cm.ErrResult[struct{}, StreamError] {
	var result cm.ErrResult[struct{}, StreamError]
	self.wasmimport_Flush(&result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.flush
//go:noescape
func (self OutputStream) wasmimport_Flush(result *cm.ErrResult[struct{}, StreamError])

// Forward represents method "forward".
//
// Forward the entire contents of an input stream to an output stream.
//
// This function repeatedly reads from the input stream and writes
// the data to the output stream, until the end of the input stream
// is reached, or an error is encountered.
//
// Unlike other I/O functions, this function blocks until the end
// of the input stream is seen and all the data has been written to
// the output stream.
//
// This function returns the number of bytes transferred, and the status of
// the output stream.
//
//	forward: func(src: own<input-stream>) -> result<u64, stream-error>
//
//go:nosplit
func (self OutputStream) Forward(src InputStream) cm.OKResult[uint64, StreamError] {
	var result cm.OKResult[uint64, StreamError]
	self.wasmimport_Forward(src, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.forward
//go:noescape
func (self OutputStream) wasmimport_Forward(src InputStream, result *cm.OKResult[uint64, StreamError])

// Splice represents method "splice".
//
// Read from one stream and write to another.
//
// This function returns the number of bytes transferred; it may be less
// than `len`.
//
// Unlike other I/O functions, this function blocks until all the data
// read from the input stream has been written to the output stream.
//
//	splice: func(src: own<input-stream>, len: u64) -> result<u64, stream-error>
//
//go:nosplit
func (self OutputStream) Splice(src InputStream, len_ uint64) cm.OKResult[uint64, StreamError] {
	var result cm.OKResult[uint64, StreamError]
	self.wasmimport_Splice(src, len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.splice
//go:noescape
func (self OutputStream) wasmimport_Splice(src InputStream, len_ uint64, result *cm.OKResult[uint64, StreamError])

// Subscribe represents method "subscribe".
//
// Create a `pollable` which will resolve once the output-stream
// is ready for more writing, or an error has occured. When this
// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
// error.
//
// If the stream is closed, this pollable is always ready immediately.
//
// The created `pollable` is a child resource of the `output-stream`.
// Implementations may trap if the `output-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
//
//	subscribe: func() -> own<pollable>
//
//go:nosplit
func (self OutputStream) Subscribe() Pollable {
	return self.wasmimport_Subscribe()
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.subscribe
//go:noescape
func (self OutputStream) wasmimport_Subscribe() Pollable

// Write represents method "write".
//
// Perform a write. This function never blocks.
//
// Precondition: check-write gave permit of Ok(n) and contents has a
// length of less than or equal to n. Otherwise, this function will trap.
//
// returns Err(closed) without writing if the stream has closed since
// the last call to check-write provided a permit.
//
//	write: func(contents: list<u8>) -> result<_, stream-error>
//
//go:nosplit
func (self OutputStream) Write(contents cm.List[uint8]) cm.ErrResult[struct{}, StreamError] {
	var result cm.ErrResult[struct{}, StreamError]
	self.wasmimport_Write(contents, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.write
//go:noescape
func (self OutputStream) wasmimport_Write(contents cm.List[uint8], result *cm.ErrResult[struct{}, StreamError])

// WriteZeroes represents method "write-zeroes".
//
// Write zeroes to a stream.
//
// this should be used precisely like `write` with the exact same
// preconditions (must use check-write first), but instead of
// passing a list of bytes, you simply pass the number of zero-bytes
// that should be written.
//
//	write-zeroes: func(len: u64) -> result<_, stream-error>
//
//go:nosplit
func (self OutputStream) WriteZeroes(len_ uint64) cm.ErrResult[struct{}, StreamError] {
	var result cm.ErrResult[struct{}, StreamError]
	self.wasmimport_WriteZeroes(len_, &result)
	return result
}

//go:wasmimport wasi:io/streams@0.2.0-rc-2023-10-18 [method]output-stream.write-zeroes
//go:noescape
func (self OutputStream) wasmimport_WriteZeroes(len_ uint64, result *cm.ErrResult[struct{}, StreamError])

// Pollable represents the resource "wasi:io/poll@0.2.0-rc-2023-10-18#pollable".
//
// See [poll.Pollable] for more information.
type Pollable = poll.Pollable

// StreamError represents the variant "wasi:io/streams@0.2.0-rc-2023-10-18#stream-error".
//
// An error for input-stream and output-stream operations.
//
//	variant stream-error {
//		last-operation-failed(own<error>),
//		closed,
//	}
type StreamError cm.Variant[uint8, Error, Error]

// StreamErrorLastOperationFailed returns a [StreamError] of case "last-operation-failed".
//
// The last operation (a write or flush) failed before completion.
//
// More information is available in the `error` payload.
func StreamErrorLastOperationFailed(data Error) StreamError {
	return cm.New[StreamError](0, data)
}

// LastOperationFailed returns a non-nil *[Error] if [StreamError] represents the variant case "last-operation-failed".
func (self *StreamError) LastOperationFailed() *Error {
	return cm.Case[Error](self, 0)
}

// StreamErrorClosed returns a [StreamError] of case "closed".
//
// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
func StreamErrorClosed() StreamError {
	var data struct{}
	return cm.New[StreamError](1, data)
}

// Closed returns true if [StreamError] represents the variant case "closed".
func (self *StreamError) Closed() bool {
	return cm.Tag(self) == 1
}
