// Code generated by wit-bindgen-go. DO NOT EDIT.

//go:build !wasip1

// Package mqtt represents the interface "fermyon:spin/mqtt@2.0.0".
package mqtt

import (
	"github.com/ydnar/wasm-tools-go/cm"
)

// Connection represents the resource "fermyon:spin/mqtt@2.0.0#connection".
//
//	resource connection
type Connection cm.Resource

// ResourceDrop represents the Canonical ABI function "resource-drop".
//
// Drops a resource handle.
//
//go:nosplit
func (self Connection) ResourceDrop() {
	self.wasmimport_ResourceDrop()
}

//go:wasmimport fermyon:spin/mqtt@2.0.0 [resource-drop]connection
//go:noescape
func (self Connection) wasmimport_ResourceDrop()

// ConnectionOpen represents static function "open".
//
// Open a connection to the Mqtt instance at `address`.
//
//	open: static func(address: string, username: string, password: string, keep-alive-interval-in-secs:
//	u64) -> result<own<connection>, error>
//
//go:nosplit
func ConnectionOpen(address string, username string, password string, keepAliveIntervalInSecs uint64) cm.ErrResult[Connection, Error] {
	var result cm.ErrResult[Connection, Error]
	wasmimport_ConnectionOpen(address, username, password, keepAliveIntervalInSecs, &result)
	return result
}

//go:wasmimport fermyon:spin/mqtt@2.0.0 [static]connection.open
//go:noescape
func wasmimport_ConnectionOpen(address string, username string, password string, keepAliveIntervalInSecs uint64, result *cm.ErrResult[Connection, Error])

// Publish represents method "publish".
//
// Publish an Mqtt message to the specified `topic`.
//
//	publish: func(topic: string, payload: payload, qos: qos) -> result<_, error>
//
//go:nosplit
func (self Connection) Publish(topic string, payload Payload, qos Qos) cm.ErrResult[struct{}, Error] {
	var result cm.ErrResult[struct{}, Error]
	self.wasmimport_Publish(topic, payload, qos, &result)
	return result
}

//go:wasmimport fermyon:spin/mqtt@2.0.0 [method]connection.publish
//go:noescape
func (self Connection) wasmimport_Publish(topic string, payload Payload, qos Qos, result *cm.ErrResult[struct{}, Error])

// Error represents the variant "fermyon:spin/mqtt@2.0.0#error".
//
// Errors related to interacting with Mqtt
//
//	variant error {
//		invalid-address,
//		too-many-connections,
//		connection-failed(string),
//		other(string),
//	}
type Error cm.Variant[uint8, string, string]

// ErrorInvalidAddress returns a [Error] of case "invalid-address".
//
// An invalid address string
func ErrorInvalidAddress() Error {
	var data struct{}
	return cm.New[Error](0, data)
}

// InvalidAddress returns true if [Error] represents the variant case "invalid-address".
func (self *Error) InvalidAddress() bool {
	return cm.Tag(self) == 0
}

// ErrorTooManyConnections returns a [Error] of case "too-many-connections".
//
// There are too many open connections
func ErrorTooManyConnections() Error {
	var data struct{}
	return cm.New[Error](1, data)
}

// TooManyConnections returns true if [Error] represents the variant case "too-many-connections".
func (self *Error) TooManyConnections() bool {
	return cm.Tag(self) == 1
}

// ErrorConnectionFailed returns a [Error] of case "connection-failed".
//
// Connection failure e.g. address not allowed.
func ErrorConnectionFailed(data string) Error {
	return cm.New[Error](2, data)
}

// ConnectionFailed returns a non-nil *[string] if [Error] represents the variant case "connection-failed".
func (self *Error) ConnectionFailed() *string {
	return cm.Case[string](self, 2)
}

// ErrorOther returns a [Error] of case "other".
//
// Some other error occurred
func ErrorOther(data string) Error {
	return cm.New[Error](3, data)
}

// Other returns a non-nil *[string] if [Error] represents the variant case "other".
func (self *Error) Other() *string {
	return cm.Case[string](self, 3)
}

// Payload represents the list "fermyon:spin/mqtt@2.0.0#payload".
//
// The message payload.
//
//	type payload = list<u8>
type Payload cm.List[uint8]

// Qos represents the enum "fermyon:spin/mqtt@2.0.0#qos".
//
// QoS for publishing Mqtt messages
//
//	enum qos {
//		at-most-once,
//		at-least-once,
//		exactly-once
//	}
type Qos uint8

const (
	QosAtMostOnce Qos = iota
	QosAtLeastOnce
	QosExactlyOnce
)
